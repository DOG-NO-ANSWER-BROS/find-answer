# 블로킹 vs 논블로킹

## 동기 vs 비동기

### 동기

* 다음 작업을 처리하기 위해서 현재 작업을 먼저 처리해야 한다.
* 작업 완료 여부를 계속해서 확인한다.

### 비동기

* 현재 작업이 끝나지 않은 상태에서 다음 작업을 진행한다.
* 작업 완료 여부를 확인하지 않는다.

![download](https://user-images.githubusercontent.com/48251668/138342870-fa377ee5-100e-4ae0-ba5a-4ed4d68a0104.png)

## 블로킹 vs 논블로킹

블로킹과 논블로킹은 주로 멀티 스레딩과 I/O 쪽에서 사용되는 개념이다.

### 블로킹

* 호출한 다른 함수 또는 요청을 보낸 api 에 제어권을 넘겨준다.

### 논블로킹

* 다른 함수를 호출하거나 api 에 요청을 보내더라도 제어권은 넘겨주지 않는다.

![download](https://user-images.githubusercontent.com/48251668/138343402-1d49550d-46a9-4617-bc6b-40124cb30d6e.png)

## 동기/비동기 vs 블로킹/논블로킹

동기/비동기와 블로킹/논블로킹은 유사하지만, 동기적으로 처리한다고 해서 모두 블로킹인 것도 아니고, 비동기라고 해서 모두 논블로킹인 것도 아니다.

### 동기 + 블로킹

* 함수를 호출하거나 api에 요청을 할 때 가장 흔한 방식 중 하나이다.
* 모든 실행과 흐름이 순차적이라 개발자가 프로그램을 제어하기 쉽다. 그리고 코드를 파악하기 비교적 쉽다.
* 작업을 위임한 (함수를 호출하거나 api에 요청을 한) 부분은 위임한 작업이 완료 여부를 신경쓴다. 여기서 부분이란 함수가 될 수도 있고, 프로세스도 될 수 있다.
* 블로킹 방식이므로 제어권이 호출된 곳으로 넘어간다. 즉, 호출한 부분은 다른 작업을 하지 않으면서 제어권을 갖고 있지 않는다.

### 동기 + 논블로킹

* 동기이므로 호출한 부분은 호출 부분이 작업을 완료 여부를 신경쓴다.
* 그런데 호출한 부분은 제어권이 있으므로 다른 작업을 할 수 있다.

### 비동기 + 논블로킹

* 이 역시도 함수를 호출하거나 api에 요청을 할 때 가장 흔한 방식 중 하나이다.
* 자원 효율에 있어서 우수하다.
* 호출한 부분은 호출된 부분의 작업 완료 여부를 신경쓰지 않는다.
* 그리고 호출한 부분은 호출된 부분의 작업 완료 여부와 상관없이 다른 작업을 할 수 있다.

### 비동기 + 블로킹

* 호출한 부분은 호출된 부분의 작업 완료 여부를 신경쓰지 않는다.
* 하지만 제어권이 넘어갔으므로 호출한 부분은 다른 작업을 할 수 없다.

#### 비동기 + 블로킹 방식을 언제 쓸까
 
* 비동기 + 논블로킹 방식을 사용하는 과정에서 의도치 않게 사용
* 직관적인 코드 흐름을 유지하면서 작업을 병렬적으로 처리하고 싶을 때
  * 예 : 동기 + 블록킹 I/O 의 경우 직관적이지만, 여러 개의 I/O를 동시에 처리할 수 없다. 논블록킹 I/O 는 프로세스들의 작업을 컨트롤하는 것이 까다롭다.

#### TMI
엔진엑스에서는 커넥선 생성, 커넥션 제거, 그리고 요청을 처리하는 것을 비동기 방식으로 프로세스들이 처리하는데, 프로세스 안에서는 하나의 쓰레드가 저 작업들을 큐에서 빼와 처리한다. 그런데 이 방식은 요청 처리가 오래 걸리면 큐 안에 있는 다른 커넥션 생성이나 요청 처리 역시 늦어진다는 단점이 있다. 즉, 블로킹이 되는 것이다. (비동기 + 블로킹) 그래서 이 문제를 해결하기 위해 엔진엑스는 처리 시간이 오래 걸리는 작업은 그 오래 걸리는 작업들만 처리하는 별도의 쓰레드에 위임한다.

## 질문

Spring 에서 WebClient 를 사용하면 요청을 비동기로 처리한다고 하는데, 그렇다면 요청을 보내고 Spring은 어떤 작업을 하나요?

[출처](https://cotak.tistory.com/136)
