# 가비지 컬렉터

가비지 컬렉터는 JVM의 heap 상에 있는 모든 객체를 추적하고 사용하지 않는 모든 것들을 제거하는 역할을 담당한다. 간단하게 가비지 컬렉터(이하 GC)는 두 단계에 걸쳐 동작한다:

1. Mark - 어떤 메모리가 사용되고 있고 어떤 것들이 사용되지 않고 있는지 파악
2. Sweep - 사용되지 않고 있는 객체를 제거

이런 가비지 컬렉터를 사용할 때 다음과 같은 장점이 있다:
* 수동으로 메모리 할당 / 해제하지 않아도 된다. 즉 휴먼 에러를 줄인다.
* Dangling Pointer 문제를 방지할 수 있다. (존재하지 않는 객체를 가리키는 포인터 방지)
* 메모리 누수 문제를 예방한다. (GC를 사용한다고 완벽하게 예방할 수는 없지만 꽤 잘 처리한다.)

하지만 다음과 같은 단점도 있다:
* JVM이 객체 참조의 생성과 소멸에 관여하다보니 CPU 사용량이 늘어난다. 이는 성능 저하가 일어날 수도 있다는 것을 의미하며, 많은 메모리를 필요로 하는 요청이 왔을 때 특히 성능 문제가 발생할 확률이 높다.
* 개발자가 스스로 더 이상 필요하지 않은 객체를 처리할 방법이 없다.
* 특정 GC 구현체를 사용하다보면 예상치 못하게 애플리케이션이 다운될 수 있다.
* 제대로 된 수동 메모리 관리보다 자동 메모리 관리가 효율적으로 안 좋을 수 있다.

## GC 알고리즘

JVM은 heap을 두 부분으로 나눈다:
1. young(Eden) generation : 새로 생성된 객체가 할당되는 곳. 대체로 100 ~ 500 MB 수준으로 작고 두 survivor space 를 가지고 있다
2. old generation : 오래된 객체가 보관되는 곳. young generation보다 훨씬 크다

* 컬렉터는 지속적으로 young generation이 얼마나 꽉 찼는지를 확인하고 소소한 GC 작업을 한다.
* 이 과정에서 생존하는 객체는 survivor space로 이동한다.
* 어느정도 생존에 성공한 객체는 old generation으로 이동하고, old generation이 포화상태가 되면 대규모 GC가 일어난다.
* 이런 GC가 일어날 때 아무 것도 일어나지 않는 "stop-the-world" 현상이 발생하는데, 이를 일시 정지 시간이라고도 한다.

### 고려할 요소
#### 1. heap 사이즈
* OS로부터 할당된 JVM의 일 처리 가능한 메모리
* 메모리가 클 수록 더 많은 객체를 담을 수 있고, 그만큼 GC 해야하는 시간이 길어진다

#### 2. 애플리케이션 데이터 사이즈
* 애플리케이션 규모가 클수록 해당 애플리케이션을 위한 메모리가 많이 필요하다
* 모든 새로운 객체는 young generation에 담길 것이라서 최대 heap 사이즈에 영향을 끼친다

#### 3. CPU 수
* 특정 알고리즘은 여러 CPU 코어가 있을 때 효과적이고, 또 어떤 알고리즘은 아니다

#### 4. 일시 정지 시간
* 다시 메모리를 확보하기 위해 멈추는 시간도 알고리즘 선택에 영향을 끼친다

#### 5. 처리량 (Throughput)
* 애플리케이션을 처리하는 시간이 많고 GC 하는 시간이 짧아야한다

#### 6. Memory Footprint
* 실제 애플리케이션을 위한 메모리인데 GC가 사용하는 경우. 한정된 환경에서는 memory footprint로 성능 확장을 한다

#### 7. 신속성 (Promptness)
* 객체가 죽고나서 해당 객체가 차지했던 메모리를 확보하기까지의 시간이 짧아야 한다
* heap 크기가 클수록 신속하지 못하다

## GC 구현체
GC는 다음 다섯 가지 구현체가 있다:
1. Serial Garbage Collector
2. Parallel Garbage Collector
3. CMS Garbage Collector
4. G1 Garbage Collector
5. Z Garbage Collector

### 1. Serial Garbage Collector
* 가장 간단한 GC 구현체
* 단일 쓰레드 위에서 돌아간다. 실행될 때 애플리케이션이 멈춘다...!
* 따라서 서버와 같은 멀티 쓰레드 환경에서는 적합하지 않다
* 그리 크지 않은 서비스, 일시 정지에 크게 민감하지 않은 애플리케이션에서 주로 쓰인다

### 2. Parallel Garbage Collector
* JVM의 GC의 디폴트 구현체로, Throughput Collectors라고 불리기도 한다 (Throughput -> 처리량)
* Serial Garbage Collector와는 달리 여러 쓰레드를 이용하여 heap을 관리한다
* 하지만 다른 애플리케이션의 쓰레드를 멈추는 것은 똑같다
* GC를 위한 쓰레드 수, 일시 정지 시간, 처리량, heap size 등을 정할 수 있다

### 3. CMS Garbage Collector
* Concurrent Mark Sweep 의 약자
* 여러 쓰레드를 이용하고, 애플리케이션의 프로세서 자원을 활용하여 일시 정지 시간을 줄인다
* 그만큼 애플리케이션이 느려진다
* Java 9에서부터 해당 GC는 depricated 되었다

### 4. G1 Garbage Collector
* 멀티 프로세서 환경에서 큰 메모리 공간을 사용할 수 있는 애플리케이션을 위해 만들어졌다
* CMS 가비지 컬렉터를 대체함
* 다른 GC와는 달리 G1 GC는 heap을 같은 크기의 서로 다른 가상의 메모리로 나눈다
* 가비지 컬렉션을 할 때 heap을 돌며 Marking 한다
* 마킹이 끝나면 스위핑을 진행해서 사용할 수 있는 공간을 마련한다

### 5. Z Garbage Collector
* 리눅스에 실험적인 요소를 위해 Java 11부터 새로 나온 GC
* 자원을 많이 필요로 하는 일은 병행성으로 해결한다. 애플리케이션 쓰레드를 10ms 보다 더 오래 멈추게 하지 않는다
* 레퍼런스 컬러링 (컬러 포인터) 이라는 개념을 사용한다. ZGC의 핵심 컨셉인데, 객체의 상태를 참조하기 위해 metadata 비트를 아용한다
* 8MB 부터 16TB 크기의 heap을 다룰 수 있으면서 그 크기에 일시 정지 시간이 영향을 받지 않는다
* 디폴트 GC가 아니다

## 질문
가비지 컬렉터가 동작하는 것을 눈으로 확인할 방법이 있을까?
