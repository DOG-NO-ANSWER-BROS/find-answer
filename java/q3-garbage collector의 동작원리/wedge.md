# 정리
## GC란?
Garbage Collector은 메모리를 효율적으로 쓰기 위한 자바의 기술 중 하나이다. 

## 어떻게?
가비지 콜렉팅을 하지 않는 자바를 상상해보자. 자바는 포인터가 없어, 특정 메모리에 맵핑되어 있는 자원을 해제할 방도가 없다. 다음과 같은 메소드가 있다. 
```java
public int add (int a, int b){
 int c = a + b;
 return c;
}
```
이 메소드가 호출 될 때마다, a와 b라는 지역변수가 생성되고 힙 메모리 한 구석을 차지할 것 이다. 하지만 이 메소드가 끝나고 나면 그 메모리는 전혀 활용할 수 없다. 
(이 메소드가 재호출된다고 해도 마찬가지다. 추가적으로 새로운 메모리가 할당 된다.)
이 과정이 반복되면, 힙 메모리는 금새 누구도 참조하지 않아 사용할 수 없는(unreachable) 값으로 가득 찰 것이다.

GC는, 일정 시간마다 발동해 누구도 참조하지 않는 객체를 찾아 소멸시킨다. 그래서 우리는 코드를 작성할 때 `너무 많은 변수를 만들어서 힙메모리가 터지면 어쩌지?ㅠㅠ` 같은 고민 없이 코딩을 할 수 있는 것이다.

## 구분동작
GC의 내부 동작 순서를 알아보자.
1. 먼저 GC roots 로부터 참조가 뻗어나간다. root로는 stack의 데이터, method의 static, JNI 객체가 있을 수 있다. 더 이상 유효한 참조가 없으면 unreachable 로 판단한다.
2. GC는 mark and sweep을 시작한다. mark는 모든 변수를 돌며, marking을 한다. reachable과 unreachable을 식별하는 과정이다.
![image](https://user-images.githubusercontent.com/51393021/132425744-523d4cf4-3b2f-4b52-8b48-9899477fe56b.png)
3. sweep은 unreachable의 메모리를 해제하는 과정이다.
4. GC 알고리즘에 따라 compact가 있기도 한다. 그 때는 sweep때 발생한 메모리 단편화를 해결한다.
![image](https://user-images.githubusercontent.com/51393021/132425985-d79c6ffd-e9ee-41f0-9f7f-9b5731cf07a6.png)

## 힙 메모리의 구조
그렇다면 GC는 힙 메모리 청소기기 때문에, 힙 메모리와 밀접한 관계를 가지고 있단걸 알 수 있다. 힙 메모리는 어떻게 구성이 되어있는가?
![image](https://user-images.githubusercontent.com/51393021/132426039-0a07773f-1002-45ad-b009-2d04cdd816d9.png)
(메타스페이스는 힙 메모리 영역은 아니지만 GC에 필요한 데이터를 담고 있는 메모리이다.) 

1. 영 제너레이션
  - 영 제너레이션은 새롭게 생성된 객체가 할당되는 공간이다.
  - 영 제너레이션은 에덴과 서바이버 공간으로 나뉜다.
  ![image](https://user-images.githubusercontent.com/51393021/132426143-666f2f17-c018-4be0-a741-d68ad1400733.png)
  1. 객체가 힙메모리에 할당 되면 우선 에덴에 할당된다. 에덴 영역이 가득 찬다면, 마이너 GC(에덴 영역에서의 mark and sweep)가 일어난다. 여기서 reachable해서 살아남은 객체는, survivor영역으로 이동한다.
  2. 살아남아서 서바이버 영역으로 이동한 객체는 age가 증가한다. 
  3. 또 다음 마이너 gc가 일어나면, 새로운 reachable 객체들은 서바이버 영역으로 이동하고, 기존 서바이버는 age가 1 증가한다.
  4. 이 과정이 반복되어 age가 일정 임계점을 돌파하면, old generation 영역으로 이동(promotion)한다.
3. 올드 제너레이션
  - 영 제너레이션에서 특정 age가 넘은 참조 메모리들이 이동하는 공간이다.
  - 이 공간이 가득차면, major GC가 일어난다.

# 질문
## 왜 영제너레이션과 올드제네레이션을 나눠야 했을까?
