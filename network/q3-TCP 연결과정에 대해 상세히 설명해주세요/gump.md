# 정리

전반적인 흐름은 이전에 정리했어요.

[[Network] OSI 7계층이란?](https://livenow14.tistory.com/54?category=993618)

[[Network] http의 특징과 각각에 대해 간략히 설명해 주세요](https://livenow14.tistory.com/45?category=993618)

<br>

TCP는 TCP/IP 모델의 3계층인 트랜스포트 계층의 프로토콜이에요. 

Port번호를 사용하여 도착지 컴퓨터의 최종 도착지인 `프로세스`에 까지 데이터가 도달하게 하는 모듈(함수)에요.

데이터를 `세그먼트(Segment, 출발지, 목적지 PORT, 전송 제어, 순서 검증 정보)`로 감싸요

데이터 전달 보증, 순서를 보장 할 수 있는 이유는 3Way handshake과정이 있기 때문이에요.

<br>

애플리케이션 계층과 트랜스포트 계층 사이에는 **소켓**이라는 것이 존재해요. 소켓은 네트워크(트랜스포트 게층)에서 프로세스(애플리케이션)로 데이터를 전달하며, 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 해요.

그러므로 수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않아요. 주어진 시간에 수신측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 유일한 식별자를 가져요. 이 식별자의 포맷은 `UDP 소캣`인지, `TCP 소캣`인지에 따라 달라져요.

이때 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 역다중화, 그 반대를 다중화라 해요.

> 좀더 깊은 얘기는 이번 포스트에서 안다루기로 해요.

 

<br>

## TCP **프로세스 연결 과정**

TCP는 연결지향 프로토콜로, 클라이언트와 서버가 서로에게 데이터를 보내기 전, 먼저 TCP 연결 설정을 할 필요가 있음을 의미해요.

TCP연결을 생성할 때 클라이언트 소켓 주소(IP 주소와 포트 번호)와 서버 소켓 주소(IP 주소와 포트 번호)를 연결과 연관시켜요.

TCP연결이 설정된 후, 한쪽에서 다른 쪽으로 데이터를 보내려면 소켓을 통해 데이터를 TCP 연결로 보내면 돼요.

UDP에서는 서버가 패킷을 소켓에게 제공하기 전 패킷에 목적지 주소를 붙여햐 하지만. TCP는 그렇지 않다는것이 다른점이에요.

![https://user-images.githubusercontent.com/48986787/120215180-64e83f80-c270-11eb-9b26-f93136ae12a2.png](https://user-images.githubusercontent.com/48986787/120215180-64e83f80-c270-11eb-9b26-f93136ae12a2.png)

서버 프로그램은 임의의 컴퓨터에서 수행되고 있는 클라이언트로부터의 초기 접속을 처리하는 `특별한 출입문(즉, 특별한 소켓)`을 가져야 해요. 여기서는 환영소켓이라 불러요. 

서버 프로세스가 실행되면, 클라이언트 프로세스는 서버로 TCP 연결을 시도해요. 이러한 초기 접속을 "출입문을 두드리는 것"으로 표현해요. 이는 클라이언트 프로세스에서 TCP 소켓을 생성함으로써 가능해요.

클라이언트는 TCP 소켓을 생성할 때 서버에 있는 `환영(welcom)소켓`의 주소, 즉 `서버의 IP 주소와 소켓의 포트 번호`를 명시해요. 소켓을 생성한 후 서버에게 3-way 핸드세이크를 시도해요. 이상이 없다면, 서버는 이 클라이언트에게 지정된 연결 소켓을 생성해요. 즉, 그림과 같이 TCP 연결이 설정돼요.

전송 계층에서 일어나는 3-way 핸드세이크를 클라이언트와 서버 프로그램은 전혀 인식하지 못해요.

> 전반적인 프로세스 연결 과정은 확인했는데, 그래서 3-way 핸드세이크는 어떻게 이뤄지죠?

간략화된 3-way 핸드셰이크 부분을 조금더 들어가보도록 해요.

<br>

## **TCP 연결과정(3-way 핸드셰이크)**

![https://user-images.githubusercontent.com/48986787/120509723-b96ff400-c403-11eb-97f8-fde625d75fdc.png](https://user-images.githubusercontent.com/48986787/120509723-b96ff400-c403-11eb-97f8-fde625d75fdc.png)

**연결 요청단계(1단계)**: 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신해요. 이 특별한 세그먼트는 `애플리케이션 계층 데이터를 포함하지 않아`요. 세그먼트 헤더에 `SYN 비트`라고 불리는 하나의 플래그 비트를 가져요. 이러한 특별한 세그먼트를 `SYN 세그먼트`라 불러요.
추가로 클라이언트는 `최초의 순서번호(client_isn)`을 선택하고, 최초의 TCP SYN 세그먼트의 `순서번호 필드`에 이 번호를 넣어요. 이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신돼요.(그림확인)

**연경 승인단계(2단계)**: 1단계에서 보낸 데이터그램이 서버 호스트에 도착했을 때, 서버는 데이터 그램에서 TCP SYN 세그먼트를 뽑아내요. 그리고 연결에 TCP 버퍼와 변수들을 할당해요. 또한 클라이언트 TCP로 연결 승인 세그먼트를 송신해요(그림확인).
 이 연결 승인 세그먼트도 `애플리케이션 데이터를 포함하지 않아`요. 그러나 세그먼트 헤더 안에 3개의 중요한 정보를 포함해요. 1. SYN비트는 1로 설정돼요. 2. TCP 세그먼트 헤더의 `확인응답 필드`는 client_isn+1로 설정돼요. 3. 자신의 `최초의 순서번호(server_isn)`을 선택하고, TCP 세그먼트 헤더의 `순서번호 필드`에 이 값을 넣어요. 
이 과정은 "나는 당신의 최초 순서번호(`client_isn`)를 가지고 연결을 시작하기 위해서 당신의 SYN 패킷을 수신했다. 이 연결설정에 동의하고, 나의 최초 순서번호는 `server_isn`이다"라고 말하는 것과 같아요. 
연결 승인 세그먼트는 `SYN-ACK 세그먼트`라 불려요.

**ACK 단계(3단계)**: `SYNACK`를 수신한 클라이언트는 연결에 버퍼와 변수들을 할당해요. 그 다음에 클라이언트 호스트는 서버로 또 다른 세그먼트를 송신해요(그림확인).
이 마지막 세그먼트가 서버의 연결 승인 세그먼트를 확인해요(클라이언트는 TCP 세그먼트 헤더의 `확인응답 필드`안에 server_isn+1 값을 넣는 것으로 그 일을 해요). 연결이 설정되었기 때문에 SYN 비트는 0으로 설정돼요. 3 way 핸드셰이크의 세 번째 단계는 클라이언트에서 서버로 세그먼트 페이로드에 데이터를 보낼 수 있어요.  

### 결론적으로, 앞의 세 단계가 완료되면

클라이언트와 서버 호스트들은 각각 서로에게 데이터를 포함하는 세그먼트를 보낼 수 있어요. 이 각각의 다음 세그먼트들에 `SYN 비트는 0으로 설정`돼요.

두 호스트들 사이에 3개의 패킷이 송신되는 이유로 TCP 연결 설정 절차를 `3way 핸드셰이크라`고 불러요. 

<br>

# 질문

## 나만 알만한 것

### 질문

TCP 연결설정이 완료되고, 데이터 이동시에 세그먼트가 가지는 값들은 어떤것들이 있을까요?

### 답변

<br>

## 진짜 궁금한 것

### 질문

각 단계에서 연결이 끊겼을 때 일어나는 일들.