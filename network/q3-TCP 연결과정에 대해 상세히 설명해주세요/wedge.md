# 프로토콜 스택은 TCP 연결을 준비한다

1. 우리의 어플리케이션(브라우저)은 다른 서버와 연결을 위해 OS의 Socket라이브러리를 이용한다. OS의 프로토콜 스택은 어플리케이션의 의뢰에 따라 한 개의 소켓을 만든다.
2. 프로토콜 스택은 소켓의 정보를 담은 디스크립터를 어플리케이션의 반환한다. 디스크립터는 해당 소켓의 번호표와 같은 것이다.
    - 이후 어플리케이션은 디스크립터를 활용하여 프로토콜 스택과 교류한다. 해당 소켓이 어떤 소켓과 연결되어 있는지는 프로토콜 스택이 관리하므로 어플리케이션은 연결되어 있는 상대에 대해 알 필요가 없다.
3. 소켓이 만들어지면 어플리케이션은 프로토콜 스택에 접속을 요청한다. 이 접속은 브라우저의 경우 URL에 입력된 IP와 포트 번호를 브라우저에게 알리는 것으로 시작한다. 
   하지만 OS 입장에서 서버와 무조건 연결할 수 는 없다. 연결이 수립 가능한지 확인해보는 절차가 필요하다.
4. 그러기 위해 연결을 수립하기 전 서버와 클라이언트는 '제어 정보'를 주고 받는다. 상대에게 통지하기 위한 제어 정보를 담는 헤더를 TCP 헤더라고 부른다. 다음과 같은 데이터 형태를 보내는 것으로 네트워크는 시작된다.
    - 그러므로 접속 계층에서 만드는 패킷의 구조는 다음과 같다.
    [ [IP,이더넷 헤더][TCP 헤더][데이터 조각] ]
    
# TCP가 관여하기 시작합니다.
1. 최초 패킷을 보낼 때 TCP 컨트롤 비트 헤더(6비트) 중 SYN비트를 1로 바꾸어준다. 이는 소켓 연결을 위한 요청을 시작한다는 의미이다.
2. 수신은 서버는 클라이언트가 TCP 헤더를 만들었듯이 응답을 돌려주기 위한 TCP 헤더를 만든다.(제어 정보를 입력한다) 이 때는 응답을 받았다는 의미로 SYN 뿐만 아니라 ACK 컨트롤 비트를 1로 만든다.
   - 어떤 이유로든 서버측 소켓에 연결을 할 수 없는 경우 SYN이 아니라 RST 컨트롤 비트를 1로 만든다. 
3. 클라이언트는 ACK 응답을 확인했다는 의미에서 다시 한 번 ACK비트를 1로 만든 TCP헤더를 반송한다. 이로써 소켓의 연결이 수립되고, 서버 소켓과 클라이언트 소켓은 데이터를 주고 받을 수 있는 상태가 된다.
4. 이를 세손악수라고 부른다.

# 연결이 되고나면
1. 데이터를 입력한 패킷을 전송하기 시작한다. 네트워크 비용과 효율을 모두 고려해야 되기 때문에, OS는 데이터를 적당한 크기로(OS마다 다름) 쪼개기 시작한다. 쪼갠 데이터 쪼가리를 전송하기 위해 TCP헤더와 IP헤더를 부착한다.
2. TCP 프로토콜은 신뢰성 있는 연결 확립이 주 목적이므로, 상대가 패킷을 제대로 수신받지 못했다면 재송신하는 기능을 갖추고 있다. 수신 여부를 확인하기 위해 시퀀스 번호라는 항목을 TCP 헤더에 기록한다.
3. 시퀀스 번호는 원본 데이터의 바이트 수를 센 것이다. 수신측은 수신한 TCP헤더를 조사하여 [ 전송받은 패킷의 바이트 수 -  헤더의 바이트 수 ] 를 뺸 값을 확인해서 시퀀스 번호와 비교한다.
4. 그 이후 시퀀스 번호에 1을 더해 ACK 번호를 되돌려보낸다. 예를 들어 1460바이트까지 수신 완료 했다면, 1461을 ACK 번호에 기록하여 송신측으로 되돌려준다. 이 동작을 수신 확인 응답이라고 부르며, 송신측은 이를 통해 상대가 어디까지 수신했는지를 파악한다. 

