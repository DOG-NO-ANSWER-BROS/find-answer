# 정리

전반적인 흐름은 이전에 정리했어요.

[[Network] OSI 7계층이란?](https://livenow14.tistory.com/54?category=993618)

[[Network] http의 특징과 각각에 대해 간략히 설명해 주세요](https://livenow14.tistory.com/45?category=993618)

<br>

TCP는 TCP/IP 모델의 3계층인 트랜스포트 계층의 프로토콜이에요. 

Port번호를 사용하여 도착지 컴퓨터의 최종 도착지인 `프로세스`에 까지 데이터가 도달하게 하는 모듈(함수)에요.

데이터를 `세그먼트(Segment, 출발지, 목적지 PORT, 전송 제어, 순서 검증 정보)`로 감싸요

데이터 전달 보증, 순서를 보장 할 수 있는 이유는 3Way handshake과정이 있기 때문이에요.

<br>

애플리케이션 계층과 트랜스포트 계층 사이에는 **소켓**이라는 것이 존재해요. 소켓은 네트워크(트랜스포트 게층)에서 프로세스(애플리케이션)로 데이터를 전달하며, 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 해요.

그러므로 수신 측 호스트의 트랜스포트 계층은 실제로 데이터를 직접 프로세스로 전달하지 않아요. 주어진 시간에 수신측 호스트에 하나 이상의 소켓이 있을 수 있으므로, 각각의 소켓은 유일한 식별자를 가져요. 이 식별자의 포맷은 `UDP 소캣`인지, `TCP 소캣`인지에 따라 달라져요.

이때 트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 역다중화, 그 반대를 다중화라 해요.

> 좀더 깊은 얘기는 이번 포스트에서 안다루기로 해요.

 

<br>

## TCP **프로세스 연결 과정**

TCP는 연결지향 프로토콜로, 클라이언트와 서버가 서로에게 데이터를 보내기 전, 먼저 TCP 연결 설정을 할 필요가 있음을 의미해요.

TCP연결을 생성할 때 클라이언트 소켓 주소(IP 주소와 포트 번호)와 서버 소켓 주소(IP 주소와 포트 번호)를 연결과 연관시켜요.

TCP연결이 설정된 후, 한쪽에서 다른 쪽으로 데이터를 보내려면 소켓을 통해 데이터를 TCP 연결로 보내면 돼요.

UDP에서는 서버가 패킷을 소켓에게 제공하기 전 패킷에 목적지 주소를 붙여햐 하지만. TCP는 그렇지 않다는것이 다른점이에요.

![https://user-images.githubusercontent.com/48986787/120215180-64e83f80-c270-11eb-9b26-f93136ae12a2.png](https://user-images.githubusercontent.com/48986787/120215180-64e83f80-c270-11eb-9b26-f93136ae12a2.png)

서버 프로그램은 임의의 컴퓨터에서 수행되고 있는 클라이언트로부터의 초기 접속을 처리하는 `특별한 출입문(즉, 특별한 소켓)`을 가져야 해요. 여기서는 환영소켓이라 불러요. 

서버 프로세스가 실행되면, 클라이언트 프로세스는 서버로 TCP 연결을 시도해요. 이러한 초기 접속을 "출입문을 두드리는 것"으로 표현해요. 이는 클라이언트 프로세스에서 TCP 소켓을 생성함으로써 가능해요.

클라이언트는 TCP 소켓을 생성할 때 서버에 있는 `환영(welcom)소켓`의 주소, 즉 `서버의 IP 주소와 소켓의 포트 번호`를 명시해요. 소켓을 생성한 후 서버에게 3-way 핸드세이크를 시도해요. 이상이 없다면, 서버는 이 클라이언트에게 지정된 연결 소켓을 생성해요. 즉, 그림과 같이 TCP 연결이 설정돼요.

전송 계층에서 일어나는 3-way 핸드세이크를 클라이언트와 서버 프로그램은 전혀 인식하지 못해요.

> 전반적인 프로세스 연결 과정은 확인했는데, 그래서 3-way 핸드세이크는 어떻게 이뤄지죠?

간략화된 3-way 핸드셰이크 부분을 조금더 들어가보도록 해요.

<br>

## **TCP 연결과정(3-way 핸드셰이크)**

![https://user-images.githubusercontent.com/48986787/120588352-01c5fb00-c472-11eb-876c-295e35fb64df.png](https://user-images.githubusercontent.com/48986787/120588352-01c5fb00-c472-11eb-876c-295e35fb64df.png)

**연결 요청단계(1단계)**: 클라이언트 측 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신해요. 이 특별한 세그먼트는 `애플리케이션 계층 데이터를 포함하지 않아`요. 세그먼트 헤더에 `SYN 비트`라고 불리는 하나의 플래그 비트를 가져요. 이러한 특별한 세그먼트를 `SYN 세그먼트`라 불러요.
추가로 클라이언트는 `최초의 순서번호(client_isn)`을 선택하고, 최초의 TCP SYN 세그먼트의 `순서번호 필드`에 이 번호를 넣어요. 이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신돼요.(그림확인)

### TCP Flag?

![https://user-images.githubusercontent.com/63634505/120180198-6ef54880-c246-11eb-8051-4ca58e68fcb8.png](https://user-images.githubusercontent.com/63634505/120180198-6ef54880-c246-11eb-8051-4ca58e68fcb8.png)

- URG - 긴급! (urgent)
- ACK - 요청에 대한 확인 응답! (acknkowledgment)
- PSH - 데이터 즉시 통과 (push)
- RST - 강제 종료 (reset)
- SYN - 클라이언트, 서버의 일련번호 확인 (synchronize)
- FIN - TCP 연결 종료. 더 이상 보낸 데이터 없음을 표시 (finish)

**연경 승인단계(2단계)**: 1단계에서 보낸 데이터그램이 서버 호스트에 도착했을 때, 서버는 데이터 그램에서 TCP SYN 세그먼트를 뽑아내요. 그리고 연결에 TCP 버퍼와 변수들을 할당해요. 또한 클라이언트 TCP로 연결 승인 세그먼트를 송신해요(그림확인).
 이 연결 승인 세그먼트도 `애플리케이션 데이터를 포함하지 않아`요. 그러나 세그먼트 헤더 안에 3개의 중요한 정보를 포함해요. 1. SYN비트는 1로 설정돼요. 2. TCP 세그먼트 헤더의 `확인응답 필드`는 client_isn+1로 설정돼요. 3. 자신의 `최초의 순서번호(server_isn)`을 선택하고, TCP 세그먼트 헤더의 `순서번호 필드`에 이 값을 넣어요. 
이 과정은 "나는 당신의 최초 순서번호(`client_isn`)를 가지고 연결을 시작하기 위해서 당신의 SYN 패킷을 수신했다. 이 연결설정에 동의하고, 나의 최초 순서번호는 `server_isn`이다"라고 말하는 것과 같아요. 
연결 승인 세그먼트는 `SYN-ACK 세그먼트`라 불려요.

**ACK 단계(3단계)**: `SYNACK`를 수신한 클라이언트는 연결에 버퍼와 변수들을 할당해요. 그 다음에 클라이언트 호스트는 서버로 또 다른 세그먼트를 송신해요(그림확인).
이 마지막 세그먼트가 서버의 연결 승인 세그먼트를 확인해요(클라이언트는 TCP 세그먼트 헤더의 `확인응답 필드`안에 server_isn+1 값을 넣는 것으로 그 일을 해요). 연결이 설정되었기 때문에 SYN 비트는 0으로 설정돼요. 3 way 핸드셰이크의 세 번째 단계는 클라이언트에서 서버로 세그먼트 페이로드에 데이터를 보낼 수 있어요.  

### 결론적으로, 앞의 세 단계가 완료되면

클라이언트와 서버 호스트들은 각각 서로에게 데이터를 포함하는 세그먼트를 보낼 수 있어요. 이 각각의 다음 세그먼트들에 `SYN 비트는 0으로 설정`돼요.

두 호스트들 사이에 3개의 패킷이 송신되는 이유로 TCP 연결 설정 절차를 `3way 핸드셰이크라`고 불러요. 

## 4 way-handshake(Connection Close)

TCP 연결을 종료시, 연결 순서와 마찬가지로 데이터의 안정성을 위해 서버와 클라이언트 간 FIN을 통하여 안정적으로 종료하는 과정 수행 → 4 way-handshake

1. 클라이언트가 FIN + ACK 송신 → 클라이언트에서 서버로 연결을 종료한다는 메시지를 보냄
2. Server 가 ACK 송신

    → FIN에 대한 응답을 한후, 전송할 데이터가 없는지 확인 →Server에서 남은 패킷 송신(일정 시간 대기)

3. Server가 FIN+ACK 송신 → 서버에서 클라이언트로 종료해도 좋다는 메시지를 보낸다.
4. Client 가 ACK 송신 → 클라이언트에서 서버로 응답을 보내고 연결 종료

### 연결 종료 - 4방향 핸드셰이크

- FIN-ACK : 클라이언트가 연결 종료하겠다는 FIN 플래그 전송
- ACK : 서버 확인 메시지 전송, 그리고 자신의 통신 끝날 때까지 기다림
- FIN-ACK : 서버가 통신이 끝났다고 다시 전송
- ACK : 클라이언트 확인 응답

## TCP의 문제점

- 시간손실 발생
- 패킷을 조금만 손실해도 재전송

<br>

## Refer

[https://mr-zero.tistory.com/36](https://mr-zero.tistory.com/36)

## 질문

### **RFC란 뭘까?**

네트워크, 아니 전체적인 CS 관련 내용을 보면 rfc 문서를 많이 접한다. 이런 문서를 보면 쫄아야할까? 아니면 뭔지 알아야할까?
당연히 알면 좋으니 한 번 보도록 한다.

- WHAT: Request for Comments, 즉 비평을 기다리는 문서
- WHO: [ISOC](https://en.wikipedia.org/wiki/Internet_Society)가 출간. 기술자 및 과학자들이 작성.
- 일련 번호가 부여된다 ex: [rfc-675](https://datatracker.ietf.org/doc/html/rfc675)
- **폐지되지 않는다** 수정이 필요하면 다른 rfc를 출간하여 이전 버전을 무효화함을 명시한다 (위의 rfc-675도 들어가보면 rfc-7805 때문에 무효화 됨)
- 그래서 자연스럽게 rfc는 인터넷의 역사가 된다.
- **IETF가 인터넷 표준으로 받아들이는 rfc도 있다.** 즉, 꼭 표준이 아닌 것들도 많다. 애초에 '비평을 기다리는 문서'.

### 서버가 먼저 클라이언트에게 요청을 보내는 경우는 어떻게 될까?

### SYN, ACK 를 보낼때 같이보내는 SEQ, ACK번호는 보안에서 중요한데 왜 그런가?

![https://user-images.githubusercontent.com/63634505/120180044-4a00d580-c246-11eb-981e-712c4ff20f79.png](https://user-images.githubusercontent.com/63634505/120180044-4a00d580-c246-11eb-981e-712c4ff20f79.png)