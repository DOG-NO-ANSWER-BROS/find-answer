# SOLID
SOLID란 객체 지향적인 설계를 고려하여 프로그래밍을 할 때 적용할만한 원칙을 다섯가지로 정리한 것을 말한다. 프로그래머가 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 적용할 수 있다.

다음 다섯 원칙의 앞글자를 따서 만들었다. 앞으로는 한글 명칭 또는 줄임말을 사용하겠다.
1. Single Responsibility Principle (SRP, 단일 책임 원칙)
2. Open/Closed Principle (OCP, 개방/폐쇄 원칙)
3. Liskov Substitution Principle (LSP, 리스코프 치환 원칙)
4. Interface Segregation Principle (ISP, 인터페이스 분리 원칙)
5. Dependency Inversion Principle (DIP, 의존관계 역전 원칙)

## 단일 책임 원칙 (SRP)
### "한 클래스는 하나의 책임만 가져야 한다."
* 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 한다.
* 클래스를 한 관심사에 집중하도록 유지해야 클래스가 더욱 튼튼하게 만들어진다.
* 편집 과정에 변경이 일어나면, 같은 클래스의 일부로 있는 출력 코드가 망가질 위험이 대단히 높다.

## 개방/폐쇄 원칙 (OCP)
### "소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다"
개방-폐쇄 원칙은 시스템의 구조를 올바르게 재조직(리팩토링)하여 한 곳의 변경이 다른 모듈의 변경을 유발하는 것을 막는 원칙이다.
이 원칙을 따르면 기능을 추가하거나 변경해야 할 때 이미 제대로 동작하고 있던 원래 코드를 변경하지 않아도 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.
개방/폐쇄 원칙에는 이름에서 유추해볼 수 있는 두 가지 특징이 있다.

* 확장에 열려 있다. (모듈을 수정해서 요구 사항의 변경에 맞게 기능을 추가할 수 있다)
* 수정에 닫혀 있다. (모듈의 소스코드나 바이너리를 수정하지 않아도 기능 확장이나 변경이 가능하다)

### 추상화
개방/폐쇄 원칙은 객체의 명세서를 작성하는 추상화를 통해 지킬 수 있다. 모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있고, 반대로 새로운 구현체를 만들어서 확장을 할 수 있다.

## 리스코프 치환 원칙 (LSP)
### "프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다."
자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다.

### LSP 위반 사례 (Circle-ellipse problem)
직사각형 클래스를 만든 다음, getter 와 setter 를 사용해서 너비와 높이를 지정하여 정사각형 클래스를 만들 때가 대표적인 LSP 위반 사례다.
정사각형 객체가 직사각형을 다루는 문맥에서 사용되는 경우, 정사각형의 크기는 독립적으로 변경할 수 없기 때문에 예기치 못한 행동을 하게 된다.
물론 필드를 final 처리해서 가변성을 제거해주면 LSP 위반이 발생하지 않는다.

## 인터페이스 분리 원칙 (ISP)
### "특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다."
클래스는 자신이 사용하지 않는 메서드에 의존하지 않아야한다.
그러기 위해 인터페이스를 구체적이고 작은 단위로 분리시킨다.
그러면 해당 인터페이스를 사용하는 클라이언트가 꼭 필요한 메서드만 골라서 이용할 것이다.
ISP는 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다.

## 의존관계 역전 원칙 (DIP)
### "추상화에 의존해야지, 구체화에 의존하면 안된다."
상위 계층(명세서)이 하위 계층(구현체)에 의존하는 의존관계를 역전시켜서 상위 계층이 하위 계층으로부터 독립되게 한다. 
DIP는 이렇게 모듈을 분리하는 형식이다. 이를 통해 상위 객체와 하위 객체가 모두 동일한 추상화에 의존한다는 객체 지향적 설계의 특징이 생긴다. 두 가지 특징을 가지고 있다.

1. 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
2. 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.

## 질문
* 실생활에서 SOLID 원칙이 잘 지켜지고 있다고 생각하나요? 개방/폐쇄 원칙의 "수정에 닫혀 있다"만 봐도, 현실의 개발 프로세스를 보면 거의 항상 소스코드나 바이너리가 되기 마련이라서요.

## 참고
https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)
https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%B1%85%EC%9E%84_%EC%9B%90%EC%B9%99
https://ko.wikipedia.org/wiki/%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84_%EC%9B%90%EC%B9%99
https://ko.wikipedia.org/wiki/%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84_%EC%B9%98%ED%99%98_%EC%9B%90%EC%B9%99
https://en.wikipedia.org/wiki/Circle%E2%80%93ellipse_problem
https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4_%EB%B6%84%EB%A6%AC_%EC%9B%90%EC%B9%99
https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84_%EC%97%AD%EC%A0%84_%EC%9B%90%EC%B9%99
