# 정리

Hibernate는 EJB의 엔티티빈을 대체하기위해 등장했다. 개빈 킹이라는 개발자의 노고로 RDB-객체 캡핑 라이브러리(ORM)인 하이버네이트가 탄생했고,
이후 EJB가 시장에서 밀려나고 하이버네이트의 점유율이 올라가자 Hibernate를 ORM 표준으로 정의하기 위해 자바진영이 움직이기 시작한다.
그렇게 정의된 것이 JPA이다.

그러면 ORM의 원조, JPA의 원조인 하이버네이트란 무엇일까?
객체와 관련된 쿼리를 자동으로 생산해주는 라이브러리이다. 개발자는 SQL에 신경쓰지 않고, 객체 관계에 대해서만 신경쓰면
DB에 저장하는 일련의 과정(SQL, 트랜잭션)은 하이버네이트가 해준다.

# 패러다임의 전환

이것은 패러다임의 전환이다. 이전까지 Database는 중요하고 프로그램은 비교적 덜 중요했다. DB 스토리지의 구축과 비용은 어마어마했고, 그에 비해 
테이블을 먼저 설계하고 프로그램은 뒷전이었으며, 코딩은 이미 완성된 쿼리들에 프로그램을 짜맞추는 과정이었다. 그러나 하이버네이트의 대두는 
프로그램을 빠르게 작성하고, SQL에 대해선 약간의 주의만 기울이면 되도록 바뀌었다. SQL을 직접 다루지 않는 대신 객체설계를 탄탄하게 가져갈 수 있게 되었다. 
이는 객체지향의 장점인 유지보수성을 살리면서, DB와의 연계성도 확보할 수 있는 새로운 패러다임이었다.

# 구현

DB에 저장되는 객체인 엔티티와 엔티티들을 관리하는 세션팩토리(JPA에선 엔티티매니저 팩토리)로 이루어진다. 세션 팩토리는 싱글톤으로 유지하며, DB 트랜잭션을 의미하는 세션을 만든다. 
세션팩토리를 통해 어플리케이션 단에서 2개의 캐시 시스템을 구성할 수 있다. 캐시는 한번 조회한 결과에 대해 어플리케이션에 저장함으로써 별도의 DB연결을 하지 않는 방식이다. 
세션에 속한 엔티티의 변화를 추적하여 쿼리를 자동으로 생산해준다. 이를 통해 서비스 로직의 흐름에 따라 별도의 persistence layer 접근로직 없이 DB연동이 되도록 만들어준다.

## 장점

1. 서비스 레이어 코드가 깔끔해진다 -> 가독성 향상
2. 객체에 비즈니스 로직을 몰아줄 수 있다. 객체 분리가 잘 된다.

## 단점

1. 쿼리가 보이지 않아 내가 원하는 펄시스턴스 로직을 구현하기가 어렵다. n+1문제가 빈번하게 일어나며, 익숙하지 않은 상태에선 문제 해결이 어렵다.
2. 초반 학습곡선이 높다

# 결론
초반 학습곡선만 극복하면 정말 장점이 많은 프레임워크라고 생각한다. 

# 질문
복잡한 통계쿼리 같은 조회쿼리는 어떻게 처리해야할까?
HQL과 JPQL은 어떤 차이가 있을까?
