# 사용자의 요청을 Spring thread 관점에서 설명

## 프로세스와 쓰레드
* 프로세스 : 실행 중인 프로그램. 

* 쓰레드 : 프로세스의 실행 단위.
    - 멀티쓰레드 : code, data, file 은 공유. register, stack은 각자 따로 할당.
    - stack : 메서드의 파라미터, 로컬 변수, 그리고 되돌아갈 주소값과 같은 것들을 저장하기 위해 사용되는 메모리 공간.
    - stack이 각자 할당되어 있다는 것은 독립적인 함수 호출이 가능하다는 것. 즉, 독립적인 실행 흐름을 가지고 있다.
  
## 누구나 해볼만한 질문 "컨트롤러 하나가 요청 100만개를 다 처리하나?"
Spring은 bean을 관리할 때 객체 하나만을 만들어서 모든 요청에 사용한다. (스코프를 prototype으로 바꾸면 요청마다 새로운 객체를 만들기는 한다.)
그렇다면 이용자가 많은 서버에서는 하나의 controller 객체가 그 많은 요청을 모두 처리할까?
발상의 전환이 필요하다. 🤔

### Tomcat과 thread
* 여러 request가 들어옴 -> 여러 thread가 생성됨
* 각각의 thread가 singleton으로 생성된 bean을 참고하여 response를 반환.
* 즉, **controller가 요청을 처리한다기 보다, thread가 컨트롤러를 참고하여 직접 처리한다고 봐야한다.**

### JVM (디테일한건 해당 주제에서!)
* JVM Memory 안에 있는 Method Area (메서드 영역)에 컨트롤러에 대한 정보가 올라간다.
* 즉, 객체는 힙에 생성되지만 그 객체를 만든 class의 정보는 메서드 영역에 생성됨.
* 쓰레드는 이를 참고하여 일을 수행한다!

### Bean은 상태가 없다
* 있을 수도 있지만, 싱글톤으로 만들기 때문에 thread safe 관련 고민을 해줘야한다... -> 차라리 singleton이 아닌 prototype으로 생성하는게 낫다. (추측)
* 있다면 예상하지 못한 문제가 생기거나 race condition이 발생할 수 있다.

## 정리해보자.
* Spring은 bean들을 싱글톤으로 관리하고, 주입이 필요할 때 객체들간의 의존을 형성한다.
* JVM의 메서드 영역에 해당 빈들의 함수가 올라간다. (모든 인스턴스가 이제 이것을 참조하게 된다.)
* Tomcat은 요청마다 threadpool에서 꺼내오는 쓰레드를 할당한다.
* 해당 쓰레드는 필요한 빈을 이용할 때 자신만의 스택에 로컬 변수와 같은 자신만의 데이터를 보관한다. (빈은 상태가 없을 것이기 때문에 빈에 변화는 없다.)
* 그렇게 요청이 처리되고 응답이 반환된다.
* 즉, 하나의 요청이 들어왔다고 해서 나머지 다른 요청이 기다릴 필요가 없다. (쓰레드 풀에 있는 쓰레드를 다 쓰면 기다리긴 해야할듯)

** 어려운 주제라 추가 학습이 필요하다**
- 쓰레드와 쓰레드 풀
- JVM

## 질문
여러 요청이 static 메서드를 사용하려 한다고 해보자. 만약 그 메서드를 실행하기 위해 1분이 걸린다면,
첫 번째 요청이 들어오고 나서 다음 요청은 1분을 기다린 후에 해당 메서드를 실행할 수 있을까?

## 정답
NO! 메서드가 static이라 해도 결국 쓰레드가 해당 메서드를 읽고 실행하는 순간 독립적인 실행이 된다.
따라서 스태틱 메서드가 1분이 걸리는 로직을 가지고 있어도, 여러 요청이 기다리지 않고 따로 그 메서드를 실행할 수 있다.
