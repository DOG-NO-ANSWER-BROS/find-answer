## 프로세스와 쓰레드

- 프로세스 : 실행 중인 프로그램.
- 쓰레드 : 프로세스의 실행 단위.
    - 멀티쓰레드 : code, data, file 은 공유. register, stack은 각자 따로 할당.
    - stack : 메서드의 파라미터, 로컬 변수, 그리고 되돌아갈 주소값과 같은 것들을 저장하기 위해 사용되는 메모리 공간.
    - stack이 각자 할당되어 있다는 것은 독립적인 함수 호출이 가능하다는 것. 즉, 독립적인 실행 흐름을 가지고 있다.

## 스레드

- 애플리케이션 코드를 순차적으로 실행하는 것
- 자바 메인 메서드를 실행하면 main 이라는 이름의 스레드가 생성
- 스레드가 없다면 자바 에플리케이션 실행이 불가
- 스레드는 한번에 하나의 코드라인만 수행
- 동시 처리가 필요하면 스레드를 추가 생성

## 단일 요청 - 스레드 하나 사용

![https://user-images.githubusercontent.com/63634505/121028238-9cac3580-c7e2-11eb-8996-1b0d563c48e6.png](https://user-images.githubusercontent.com/63634505/121028238-9cac3580-c7e2-11eb-8996-1b0d563c48e6.png)

## 다중 요청 - 스레드 하나 사용

![https://user-images.githubusercontent.com/63634505/121028361-b9e10400-c7e2-11eb-8da4-99c180f5d40d.png](https://user-images.githubusercontent.com/63634505/121028361-b9e10400-c7e2-11eb-8da4-99c180f5d40d.png)

## 다중 요청 - 요청마다 스레드 생성

![https://user-images.githubusercontent.com/63634505/121028506-dc731d00-c7e2-11eb-8e92-b4092c7aa738.png](https://user-images.githubusercontent.com/63634505/121028506-dc731d00-c7e2-11eb-8e92-b4092c7aa738.png)

## 요청 마다 스레드 생성 장단점

장점

- 동시 요청을 처리할 수 있다
- 리소스가 허용할 때까지 처리 가능
- 스레드가 지연되어도 나머지 스레드는 정상 동작

단점

- 스레드의 생성비용
- 스레드는 컨텍스트 스위칭 비용이 발생
- 스레드 생성에 제한이 없다 → 많은 요청이 오면 cpu, 메모리가 임계점을 넘어 서버가 죽을 수 있다

## 스레드 풀

![https://user-images.githubusercontent.com/63634505/121028735-04fb1700-c7e3-11eb-8b18-bc52aebdd9a2.png](https://user-images.githubusercontent.com/63634505/121028735-04fb1700-c7e3-11eb-8b18-bc52aebdd9a2.png)

## 요청 마다 스레드 생성의 단점 보완

특징

- 필요한 스레드를 스레드 풀에 보관하고 관리
- 생성 가능한 스레드의 최대치를 관리한다. tomcat 은 200개 기본 설정

사용

- 스레드가 필요하면, 이미 생성되어 있는 스레드를 스레드 풀에서 꺼내 사용
- 사용 종료시 스레드 풀에 반납
- 스레드 풀에 스레드가 없다면 요청을 거절하거나 특정 숫자만큼 대기하도록 설정 할 수 있다

장점

- 스레드가 미리 생성되어 있어 비용절약 및 시간이 빠름
- 최대치가 있어서 많은 요청이 들어와도 안전하게 처리 가능

## 우선 스프링 MVC의 요청과정을 큰 그림으로 보기로해요.

![https://user-images.githubusercontent.com/48986787/120974971-b2eacf00-c7ab-11eb-9f28-fe5f92644697.png](https://user-images.githubusercontent.com/48986787/120974971-b2eacf00-c7ab-11eb-9f28-fe5f92644697.png)

큰 흐름으로, 클라이언트가 HTTP 요청을 보내면, WAS는 TCP/IP 연결 대기 과정(`welcome 소캣`)에서 클라이언트를 위한 소캣(`연결 소캣`)을 생성해서 연결해요.

연결이후 많은과정이 일어나요. (다음 과정으로 간다는 것은, 반환되지 않았다는 얘기에요)

1. WAS는 HTTP 메세지를 파싱해서, Web Server에서만 필요한 정보면, 정적 페이지를 반환해요.
2. `Request`, `Response` 객체를 만들어 Filter 객체에게 던져줘요.
3. Filter에서 요청된 내용을 변경(`인코딩 변환 처리`)하거나,여러가지 체크(`XSS 방어`)를해요. 여기서 체크에 걸린다면, 예외를 반환해요.
4. Filter에서 `HttpServletRequest`, `HttpServletResponse`객체로 변환하고, 이를 DispatcherServlet에게 넘겨줘요. (ServletContainer가 servlet의 구현에 대한 부분을 담당하고, 이후 servlet에 요청에대한 역할을 위임하는 방식하는 방식이기 때문)
5. DispatcherServlet내의 `HandlerMapping(컨트롤러 메소드 지정)`, `HandlerAdapter(컨트롤러 메소드 실행)`인터페이스 구현체들이 실행돼요. 이때 각 인터페이스 구현 과정 중 interceptor, resolver에 만족하지 못한다면, 예외를 반환해요.
6. request의 내용(`헤더, 바디`)을 바탕으로 서비스가 실행되고, response에 서비스 결과를 넘겨줘요.

각각의 자세한 부분은 이후 포스팅에서 다루기로 할게요.

### 그렇다면, 각 과정의 자원은 공유되는 것일까요?

TCP 연결 요청에 관한 부분은 RMI를 통해 해결하기에, TCP 연결 설정에 관한 부분은 다루지 않기로해요(너무 어려워요 ㅠㅠ). 간략히, TCP 연결 쓰례드가 Servlet 쓰레드의 부모 쓰레드로 설정돼요.

모든 접근이 동일한 자원을 공유한다면, 하나의 요청이 끝날 때 까지 자원을 사용하지 못할거에요.

그렇기 때문에 스프링에서는 ThreadPool을 이용한 `Multi Thread`를 이용해요.

쓰레드는 `애플리케이션 코드를 하나하나 순차적으로 실행하는 것`이에요.

![https://user-images.githubusercontent.com/48986787/120984637-d0bd3180-c7b5-11eb-9ea9-84ccaf5b5a8f.png](https://user-images.githubusercontent.com/48986787/120984637-d0bd3180-c7b5-11eb-9ea9-84ccaf5b5a8f.png)

요청이 들어오면, `ThreadPool`에서 여유 쓰레드가 있는지 확인하고, 있다면 요쳥에 대해 쓰레드를 할당해줘요. 이 쓰레드는 servlet을 실행해요. → `여유 쓰레드가 없다면 대기하거나 거절할 수 있어요(WAS 정책에 따라 다름).`

모든 요청이 반환되면 사용된 쓰레드는 쓰레드 풀에 반환돼요.

이러한 방식의 장점으로는 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답시간이 빨라져요. 또한 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있어요.

<br>

## 누구나 해볼만한 질문 "컨트롤러 하나가 요청 100만개를 다 처리하나?"

Spring은 bean을 관리할 때 객체 하나만을 만들어서 모든 요청에 사용한다. (스코프를 prototype으로 바꾸면 요청마다 새로운 객체를 만들기는 한다.)
그렇다면 이용자가 많은 서버에서는 하나의 controller 객체가 그 많은 요청을 모두 처리할까?
발상의 전환이 필요하다. 🤔

### Tomcat과 thread

- 여러 request가 들어옴 -> 여러 thread가 생성됨
- 각각의 thread가 singleton으로 생성된 bean을 참고하여 response를 반환.
- 즉, **controller가 요청을 처리한다기 보다, thread가 컨트롤러를 참고하여 직접 처리한다고 봐야한다.**

### JVM (디테일한건 해당 주제에서!)

- JVM Memory 안에 있는 Method Area (메서드 영역)에 컨트롤러에 대한 정보가 올라간다.
- 즉, 객체는 힙에 생성되지만 그 객체를 만든 class의 정보는 메서드 영역에 생성됨.
- 쓰레드는 이를 참고하여 일을 수행한다!

### Bean은 상태가 없다

- 있을 수도 있지만, 싱글톤으로 만들기 때문에 thread safe 관련 고민을 해줘야한다... -> 차라리 singleton이 아닌 prototype으로 생성하는게 낫다. (추측)
- 있다면 예상하지 못한 문제가 생기거나 race condition이 발생할 수 있다.

## 정리해보자.

- Spring은 bean들을 싱글톤으로 관리하고, 주입이 필요할 때 객체들간의 의존을 형성한다.
- JVM의 메서드 영역에 해당 빈들의 함수가 올라간다. (모든 인스턴스가 이제 이것을 참조하게 된다.)
- Tomcat은 요청마다 threadpool에서 꺼내오는 쓰레드를 할당한다.
- 해당 쓰레드는 필요한 빈을 이용할 때 자신만의 스택에 로컬 변수와 같은 자신만의 데이터를 보관한다. (빈은 상태가 없을 것이기 때문에 빈에 변화는 없다.)
- 그렇게 요청이 처리되고 응답이 반환된다.
- 즉, 하나의 요청이 들어왔다고 해서 나머지 다른 요청이 기다릴 필요가 없다. (쓰레드 풀에 있는 쓰레드를 다 쓰면 기다리긴 해야할듯)
- * 어려운 주제라 추가 학습이 필요하다**
- 쓰레드와 쓰레드 풀
- JVM

### 사용자의 요청이 들어왔을 때

1. 스프링이 연동하고 있는 서블릿 컨테이너<sup>[1](https://www.notion.so/f1284eb4687c4a5c80c195f579cffa68)</sup>에서 웹 요청에 대한 스레드를 생성한다.
2. 위 요청을 자세히 들여다보면, 서블릿 컨테이너는 오픈한 서버 포트에 대해 들어온 요청에 대해서 새로운 소켓을 생성해 연결을 수립한다.
3. 이 과정에서 서블릿 컨테이너는 JVM 상에 스레드 하나를 생성하고, 해당 스레드가 url에 맵핑된 서블릿<sup>[2](https://www.notion.so/f1284eb4687c4a5c80c195f579cffa68)</sup>의 service메소드를 호출할 수 있게 한다.
4. 해당 스레드는 서블릿의 요청을 유저에게 응답하고 나면 destory 되거나, 스레드 풀<sup>[3](https://www.notion.so/f1284eb4687c4a5c80c195f579cffa68)</sup>을 활용한 경우 스레드 풀로 자원이 반납된다.
5. 톰캣을 비롯한 상용 서블릿 컨테이너가 멀티스레딩을 지원하는 이유는 여러 클라이언트의 요청을 동시에 병렬적으로 처리하기 위해서이다.

<br>

## 질문

### Q1. **스레드, 스레드 풀의 적정 숫자는 어떻게 찾나?**

`적정 스레드 개수 = cpu 수 * (1+ 대기, 유휴 시간/서비스 시간)`

- CPU 대기시간이 서비스 시간보다 짧다면 CPU 개수보다 스레드가 적어야 성능이 좋다.
- 대기시간이 서비스 처리 시간 보다 많다면 스레드 수는 cpu 개수보다 많아야 성능이 좋다.

`적정 스레드 풀 개수 = CPU 수 * (CPU 목표 사용량) * (1+대기 시간/서비스 시간)`

- TTP 응답 시에는 JMS(자바 메시지 서비스) 로부터의 요청, JDBC Connection Pool과 같은 애플리케이션의 영역을 고려하자면, CPU 사용량을 추가하면 된다. 이때 CPU 목표 사용량은 0~1 사이다.

### Q2. 스프링에서는 TCP연결에 관한 부분을 어떻게 해결할까?

RMI(Remote Method Invocation)를 통해

### Q3. 여러 요청이 static 메서드를 사용하려 한다고 해보자. 만약 그 메서드를 실행하기 위해 1분이 걸린다면, 첫 번째 요청이 들어오고 나서 다음 요청은 1분을 기다린 후에 해당 메서드를 실행할 수 있을까?

NO! 메서드가 static이라 해도 결국 쓰레드가 해당 메서드를 읽고 실행하는 순간 독립적인 실행이 된다.
따라서 스태틱 메서드가 1분이 걸리는 로직을 가지고 있어도, 여러 요청이 기다리지 않고 따로 그 메서드를 실행할 수 있다.

### Q4. 개인 PC와 서버가 감당할 수 있는 스레드의 개수는 어떻게 확인할 수 있을까? 스레드에 대한 부하테스트를 하는 방법이 궁금하다. 현재는 멀티 스레드의 동작 방식이 궁금할 땐 크롬을 여러 개 열어놓고 손으로 클릭하여 다중 접속 환경을 모사하는데, 스마트한 방법으론 뭐가 있을지!

<a name="footnote1">[1] 스프링부트는 기본적으로 톰캣(Tomcat)을 내장하고 있다. 톰캣이 아닌 서블릿 컨테이너는 [제로니모](http://geronimo.apache.org/), [글래스피쉬](https://javaee.github.io/glassfish/) 등이 있다.</a>

<a name="footnote2">[2] 스프링 같은 경우 프론트 컨트롤러 패턴을 활용해 dispatcher servlet 하나만을 생성하여 사용한다.</a>

<a name="footnote3">[3] 톰캣은 스레드 풀로 [org.apache.catalina.Executor](https://tomcat.apache.org/tomcat-9.0-doc/config/executor.html)를 활용한다. api를 살펴보면 최대 스레드 풀 생성 개수(200)나 최소 유휴 스레드 개수(25) 등의 기본값을 알 수 있다.</a>